#include "AxisAlignedBoundingBoxComponent.hpp"

#include "MeshRendererComponent.hpp"
#include "engine/BedrockMath.hpp"
#include "engine/entity_system/Entity.hpp"
#include "engine/entity_system/components/TransformComponent.hpp"
#include "engine/BedrockMatrix.hpp"
#include "engine/camera/CameraComponent.hpp"
#include "engine/ui_system/UI_System.hpp"
#include "tools/JsonUtils.hpp"

namespace MFA
{

    //-------------------------------------------------------------------------------------------------

    AxisAlignedBoundingBoxComponent::AxisAlignedBoundingBoxComponent(
        glm::vec3 const & center,
        glm::vec3 const & extend,
        bool const occlusionCullingEnabled
    )
        : BoundingVolumeComponent(occlusionCullingEnabled)
        //, mIsAutoGenerated(false)
        , mLocalPosition(center)
        , mExtend(extend)
    {}

    //-------------------------------------------------------------------------------------------------

    AxisAlignedBoundingBoxComponent::~AxisAlignedBoundingBoxComponent() = default;

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Init()
    {
        BoundingVolumeComponent::Init();

        mTransformComponent = GetEntity()->GetComponent<TransformComponent>();
        MFA_ASSERT(mTransformComponent.expired() == false);
        if (auto const transformComponent = mTransformComponent.lock())
        {
            mTransformChangeListener = transformComponent->RegisterChangeListener(
                [this](Transform::ChangeParams const & params)->void
                {
                    computeWorldPosition();
                }
            );
        }
        // TODO: We can auto generate same as we did for physx
        /*if (mIsAutoGenerated)
        {
            auto const rendererComponent = GetEntity()->GetComponent<MeshRendererComponent>().lock();
            MFA_ASSERT(rendererComponent != nullptr);

            auto variant = rendererComponent->getVariant();
            MFA_ASSERT(variant != nullptr);
            auto * essence = variant->getEssence();
            MFA_ASSERT(essence != nullptr);
            auto const nameId = essence->getNameId();
            MFA_ASSERT(nameId.empty() == false);

            RC::AcquireCpuModel(nameId, [this](std::shared_ptr<AS::Model> const & model)->void{
                MFA_ASSERT(model != nullptr);

                auto const mesh = model->mesh;
                MFA_ASSERT(mesh != nullptr);

                auto const & meshData = static_cast<AS::PBR::Mesh *>(mesh.get())->getMeshData();
                MFA_ASSERT(meshData->hasPositionMinMax);
                auto * positionMax = meshData->positionMax;
                auto * positionMin = meshData->positionMin;
                MFA_ASSERT(positionMax != nullptr);
                MFA_ASSERT(positionMin != nullptr);

                mExtend.x = abs(positionMax[0] - positionMin[0]);
                mExtend.y = abs(positionMax[1] - positionMin[1]);
                mExtend.z = abs(positionMax[2] - positionMin[2]);

                mLocalPosition.x = (positionMax[0] + positionMin[0]) / 2.0f;
                mLocalPosition.y = (positionMax[1] + positionMin[1]) / 2.0f;
                mLocalPosition.z = (positionMax[2] + positionMin[2]) / 2.0f;
            });
        }*/

        mRadius = Math::Max(mExtend.x, Math::Max(mExtend.y, mExtend.z)) / 2.0f;
        MFA_ASSERT(mRadius > 0);

        computeWorldPosition();
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Shutdown()
    {
        if (auto const transformComponent = mTransformComponent.lock())
        {
            transformComponent->UnRegisterChangeListener(mTransformChangeListener);
        }
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::OnUI()
    {
        if (UI::TreeNode("AxisAlignedBoundingBox"))
        {
            BoundingVolumeComponent::OnUI();

            bool changed = false;

            changed |= UI::InputFloat("Center", mLocalPosition);
            changed |= UI::InputFloat("Extend", mExtend);

            if (changed)
            {
                computeWorldPosition();
            }

            UI::TreePop();
        }
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Clone(Entity * entity) const
    {
        MFA_ASSERT(entity != nullptr);
        entity->AddComponent<AxisAlignedBoundingBoxComponent>(
            mLocalPosition,
            mExtend,
            OcclusionEnabled()
        );
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Deserialize(nlohmann::json const & jsonObject)
    {
        JsonUtils::DeserializeVec3(jsonObject, "center", mLocalPosition);
        JsonUtils::DeserializeVec3(jsonObject, "extend", mExtend);
        //mIsAutoGenerated = false;
        BoundingVolumeComponent::Deserialize(jsonObject);
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Serialize(nlohmann::json & jsonObject) const
    {
        JsonUtils::SerializeVec3(jsonObject, "center", mLocalPosition);
        JsonUtils::SerializeVec3(jsonObject, "extend", mExtend);
        BoundingVolumeComponent::Serialize(jsonObject);
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec3 const & AxisAlignedBoundingBoxComponent::GetExtend() const
    {
        return mAABB_Extent;
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec3 const & AxisAlignedBoundingBoxComponent::GetLocalPosition() const
    {
        return mLocalPosition;
    }

    //-------------------------------------------------------------------------------------------------

    float AxisAlignedBoundingBoxComponent::GetRadius() const
    {
        return mRadius;
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec4 const & AxisAlignedBoundingBoxComponent::GetWorldPosition() const
    {
        return mWorldPosition;
    }

    //-------------------------------------------------------------------------------------------------

    bool AxisAlignedBoundingBoxComponent::IsInsideCameraFrustum(CameraComponent const * camera)
    {
        MFA_ASSERT(camera != nullptr);
        return camera->IsPointInsideFrustum(mWorldPosition, mAABB_Extent);
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::computeWorldPosition()
    {
        auto const transformComponent = mTransformComponent.lock();
        if (transformComponent == nullptr) {
            return;
        }

        auto const & transform = transformComponent->GetWorldTransform();

        mWorldPosition = transform * glm::vec4(mLocalPosition, 1.f);

        // Scaled orientation
        auto forwardVec4 = Copy<glm::vec4, glm::vec3>(Math::ForwardVec3);
        forwardVec4 = transform * forwardVec4;
        auto forwardVec3 = Copy<glm::vec3, glm::vec4>(forwardVec4);
        forwardVec3 = glm::normalize(forwardVec3);
        forwardVec3 *= mExtend.z;
        
        auto rightVec4 = Copy<glm::vec4, glm::vec3>(Math::RightVec4W0);
        rightVec4 = transform * rightVec4;
        auto rightVec3 = Copy<glm::vec3, glm::vec4>(rightVec4);
        rightVec3 = glm::normalize(rightVec3);
        rightVec3 *= mExtend.x;
        
        auto upVec4 = Copy<glm::vec4, glm::vec3>(Math::UpVec4W0);
        upVec4 = transform * upVec4;
        auto upVec3 = Copy<glm::vec3, glm::vec4>(upVec4);
        upVec3 = glm::normalize(upVec3);
        upVec3 *= mExtend.y;
        
        
        const float newIi = std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, rightVec3)) +
            std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, upVec3)) +
            std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, forwardVec3));

        const float newIj = std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, rightVec3)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, upVec3)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, forwardVec3));

        const float newIk = std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, rightVec3)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, upVec3)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, forwardVec3));

        mAABB_Extent.x = newIi;
        mAABB_Extent.y = newIj;
        mAABB_Extent.z = newIk;
    }

    //-------------------------------------------------------------------------------------------------

}
