#include "AxisAlignedBoundingBoxComponent.hpp"

#include "MeshRendererComponent.hpp"
#include "engine/BedrockMath.hpp"
#include "engine/entity_system/Entity.hpp"
#include "engine/entity_system/components/TransformComponent.hpp"
#include "engine/render_system/drawable_essence/DrawableEssence.hpp"
#include "engine/BedrockMatrix.hpp"
#include "engine/camera/CameraComponent.hpp"
#include "engine/ui_system/UISystem.hpp"
#include "tools/JsonUtils.hpp"

namespace MFA
{

    //-------------------------------------------------------------------------------------------------

    AxisAlignedBoundingBoxComponent::AxisAlignedBoundingBoxComponent(
        glm::vec3 const & center,
        glm::vec3 const & extend
    )
        : mIsAutoGenerated(false)
        , mLocalPosition(center)
        , mExtend(extend)
    {}

    //-------------------------------------------------------------------------------------------------

    AxisAlignedBoundingBoxComponent::AxisAlignedBoundingBoxComponent()
        : mIsAutoGenerated(true)
    {}

    //-------------------------------------------------------------------------------------------------

    AxisAlignedBoundingBoxComponent::~AxisAlignedBoundingBoxComponent() = default;

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Init()
    {
        BoundingVolumeComponent::Init();

        mTransformComponent = GetEntity()->GetComponent<TransformComponent>();
        MFA_ASSERT(mTransformComponent.expired() == false);
        if (auto const transformComponent = mTransformComponent.lock())
        {
            mTransformChangeListener = transformComponent->RegisterChangeListener([this]()->void {computeWorldPosition();});
        }

        if (mIsAutoGenerated)
        {
            auto const meshRendererComponent = GetEntity()->GetComponent<MeshRendererComponent>().lock();
            MFA_ASSERT(meshRendererComponent != nullptr);

            auto * essence = meshRendererComponent->GetVariant()->GetEssence();
            MFA_ASSERT(essence != nullptr);
            auto * gpuModel = essence->GetGpuModel();
            MFA_ASSERT(gpuModel != nullptr);

            auto const & mesh = gpuModel->model->mesh;
            MFA_ASSERT(mesh->HasPositionMinMax());

            auto * positionMax = mesh->GetPositionMax();
            auto * positionMin = mesh->GetPositionMin();

            mExtend.x = abs(positionMax[0] - positionMin[0]);
            mExtend.y = abs(positionMax[1] - positionMin[1]);
            mExtend.z = abs(positionMax[2] - positionMin[2]);

            mLocalPosition.x = (positionMax[0] + positionMin[0]) / 2.0f;
            mLocalPosition.y = (positionMax[1] + positionMin[1]) / 2.0f;
            mLocalPosition.z = (positionMax[2] + positionMin[2]) / 2.0f;

        }

        mRadius = Math::Max(mExtend.x , Math::Max(mExtend.y, mExtend.z)) / 2.0f;
        MFA_ASSERT(mRadius > 0);

        computeWorldPosition();
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Shutdown()
    {
        if (auto const transformComponent = mTransformComponent.lock())
        {
            transformComponent->UnRegisterChangeListener(mTransformChangeListener);
        }
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::OnUI()
    {
        if (UI::TreeNode("AxisAlignedBoundingBox"))
        {
            glm::vec3 localPosition = mLocalPosition;
            
            BoundingVolumeComponent::OnUI();
            UI::InputFloat3("Center", localPosition.data.data);
            UI::InputFloat3("Extend", mExtend.data.data);
            UI::TreePop();

            if (mLocalPosition != localPosition)
            {
                mLocalPosition = localPosition;
                computeWorldPosition();
            }
        }
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Clone(Entity * entity) const
    {
        MFA_ASSERT(entity != nullptr);
        entity->AddComponent<AxisAlignedBoundingBoxComponent>(
            mLocalPosition,
            mExtend
        );
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Deserialize(nlohmann::json const & jsonObject)
    {
        JsonUtils::DeserializeVec3(jsonObject, "center", mLocalPosition);
        JsonUtils::DeserializeVec3(jsonObject, "extend", mExtend);
        mIsAutoGenerated = false;
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::Serialize(nlohmann::json & jsonObject) const
    {
        JsonUtils::SerializeVec3(jsonObject, "center", mLocalPosition);
        JsonUtils::SerializeVec3(jsonObject, "extend", mExtend);
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec3 const & AxisAlignedBoundingBoxComponent::GetExtend() const
    {
        return mExtend;
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec3 const & AxisAlignedBoundingBoxComponent::GetLocalPosition() const
    {
        return mLocalPosition;
    }

    //-------------------------------------------------------------------------------------------------

    float AxisAlignedBoundingBoxComponent::GetRadius() const
    {
        return mRadius;
    }

    //-------------------------------------------------------------------------------------------------

    glm::vec4 const & AxisAlignedBoundingBoxComponent::GetWorldPosition() const
    {
        return mWorldPosition;
    }

    //-------------------------------------------------------------------------------------------------

    bool AxisAlignedBoundingBoxComponent::IsInsideCameraFrustum(CameraComponent const * camera)
    {
        MFA_ASSERT(camera != nullptr);

        const float newIi = std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, mRightVector)) +
            std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, mUpVector)) +
            std::abs(glm::dot(glm::vec3{ 1.f, 0.f, 0.f }, mForwardVector));

        const float newIj = std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, mRightVector)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, mUpVector)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 1.f, 0.f }, mForwardVector));

        const float newIk = std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, mRightVector)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, mUpVector)) +
            std::abs(glm::dot(glm::vec3{ 0.f, 0.f, 1.f }, mForwardVector));

        return camera->IsPointInsideFrustum(mWorldPosition, glm::vec3(newIi, newIj, newIk));
    }

    //-------------------------------------------------------------------------------------------------

    void AxisAlignedBoundingBoxComponent::computeWorldPosition()
    {
        auto const transformComponent = mTransformComponent.lock();
        if (transformComponent == nullptr) {
            return;
        }

        auto const & transform = transformComponent->GetTransform();

        mWorldPosition = transform * glm::vec4(mLocalPosition, 1.f);

        // Scaled orientation
        auto forwardDirection = Math::ForwardVector;
        forwardDirection = transform * forwardDirection;
        forwardDirection = glm::normalize(forwardDirection);
        forwardDirection *= mExtend.z;
        mForwardVector = forwardDirection;

        auto rightDirection = Math::RightVector;
        rightDirection = transform * rightDirection;
        rightDirection = glm::normalize(rightDirection);
        rightDirection *= mExtend.x;
        mRightVector = rightDirection;

        auto upDirection = Math::UpVector;
        upDirection = transform * upDirection;
        upDirection = glm::normalize(upDirection);
        upDirection *= mExtend.y;
        mUpVector = upDirection;
    }

    //-------------------------------------------------------------------------------------------------

}
